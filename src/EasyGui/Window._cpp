module EasyGui;

import std;
import EasyGui.Lib;
import EasyGui.Core.KeyCodes;
import EasyGui.Core.MouseCodes;
import EasyGui.Event.AllEvents;

import <EasyGui/Lib/Lib_SDL3.hpp>;
import <EasyGui/Lib/Lib_Vulkan.hpp>;
import <EasyGui/Lib/Lib_imgui.hpp>;

namespace EasyGui {
    Window::Window(const WindowSpec &windowSpec) : m_Context(vk::raii::Context{}) {
        InitializeWindow(windowSpec);
        InitVulkan();
    }

    void Window::InitializeWindow(const WindowSpec &windowSpec) {
        SDL_WindowFlags windowFlags =
                SDL_WINDOW_VULKAN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN | SDL_WINDOW_HIGH_PIXEL_DENSITY;
        m_Window = SDL_CreateWindow(windowSpec.title.c_str(), windowSpec.width, windowSpec.height, windowFlags);
        if (!m_Window) {
            throw std::runtime_error("Failed to create SDL window: " + std::string(SDL_GetError()));
        }
    }

    void Window::InitVulkan() {
        CreateInstance();
        SetupDebugMessenger();
        CreateSurface();
        PickPhysicalDevice();
        CreateLogicalDevice();

        CreateAllocator();

        CreateSwapChain();
        CreateImageViews();

        CreateDescriptorPool();

        CreateSampler();

        CreateRenderPass();
        CreateFramebuffers();

        CreateCommandPool();
        CreateSyncObjects();
        CreateCommandBuffer();

        InitImGui();
    }

    void Window::CreateInstance() {
        if (enableValidationLayers && !CheckValidationLayerSupport()) {
            throw std::runtime_error("validation layers requested, but not available!");
        }

        vk::ApplicationInfo appInfo{
            .sType = vk::StructureType::eApplicationInfo,
            .pNext = nullptr,
            .pApplicationName = "Hello Triangle",
            .applicationVersion = vk::makeVersion(1, 0, 0),
            .pEngineName = "No Engine",
            .engineVersion = vk::makeVersion(1, 0, 0),
            .apiVersion = vk::ApiVersion13
        };

        auto extensions = GetRequiredExtensions();

        auto debugCreateInfo = PopulateDebugMessengerCreateInfo();

        // flags,
        vk::InstanceCreateInfo createInfo{
            .sType = vk::StructureType::eInstanceCreateInfo,
            .pNext = enableValidationLayers ? static_cast<const void *>(&debugCreateInfo) : nullptr,
            .flags = vk::InstanceCreateFlags{},
            .pApplicationInfo = &appInfo,
            .enabledLayerCount = enableValidationLayers ? static_cast<uint32_t>(s_ValidationLayers.size()) : 0,
            .ppEnabledLayerNames = enableValidationLayers ? s_ValidationLayers.data() : nullptr,
            .enabledExtensionCount = static_cast<uint32_t>(extensions.size()),
            .ppEnabledExtensionNames = extensions.data()
        };

        m_Instance = m_Context.createInstance(createInfo).value();
    }

    bool Window::CheckValidationLayerSupport() {
        auto availableLayers = vk::enumerateInstanceLayerProperties().value;

        for (const auto &layerName: s_ValidationLayers) {
            bool layerFound = false;
            for (const auto &layerProperties: availableLayers) {
                if (std::string_view(layerProperties.layerName) == layerName) {
                    layerFound = true;
                    break;
                }
            }
            if (!layerFound) {
                std::cerr << "Validation layer " << layerName << " not found!" << std::endl;
                return false;
            }
        }

        // std::cout << "Validation layers are supported." << std::endl;

        return true;
    }

    void Window::SetupDebugMessenger() {
        if constexpr (!enableValidationLayers) return;

        m_DebugMessenger = m_Instance.createDebugUtilsMessengerEXT(PopulateDebugMessengerCreateInfo()).value();
    }

    std::vector<const char *> Window::GetRequiredExtensions() {
        std::vector<const char *> extensions;
        uint32_t sdl_extensions_count = 0;
        const char *const *sdl_extensions = SDL_Vulkan_GetInstanceExtensions(&sdl_extensions_count);
        for (uint32_t n = 0; n < sdl_extensions_count; n++)
            extensions.push_back(sdl_extensions[n]);

        if (enableValidationLayers) {
            extensions.push_back(vk::EXTDebugUtilsExtensionName);
        }

        return extensions;
    }

    inline vk::Bool32 DebugCallback(vk::DebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                    vk::DebugUtilsMessageTypeFlagsEXT messageType,
                                    const vk::DebugUtilsMessengerCallbackDataEXT *pCallbackData,
                                    void *pUserData) {
        if (messageSeverity >= vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning) {
            std::cerr << "validation layer: " << pCallbackData->pMessage << std::endl;
        } else {
            std::cout << "validation layer: " << pCallbackData->pMessage << std::endl;
        }

        return vk::False;
    }

    vk::DebugUtilsMessengerCreateInfoEXT Window::PopulateDebugMessengerCreateInfo() {
        return vk::DebugUtilsMessengerCreateInfoEXT{
            .sType = vk::StructureType::eDebugUtilsMessengerCreateInfoEXT,
            .pNext = nullptr,
            .flags = vk::DebugUtilsMessengerCreateFlagsEXT{},
            .messageSeverity = vk::DebugUtilsMessageSeverityFlagBitsEXT::eVerbose |
                               vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |
                               vk::DebugUtilsMessageSeverityFlagBitsEXT::eError,
            .messageType = vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |
                           vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |
                           vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance,
            .pfnUserCallback = DebugCallback,
            .pUserData = nullptr
        };
    }

    void Window::PickPhysicalDevice() {
        auto physicalDevices = m_Instance.enumeratePhysicalDevices().value();
        if (physicalDevices.empty()) {
            throw std::runtime_error("failed to find GPUs with Vulkan support!");
        }

        for (const auto &device: physicalDevices) {
            if (IsDeviceSuitable(device)) {
                m_PhysicalDevice = device;
                std::cout << "Physical device selected: " << device.getProperties().deviceName << std::endl;
                return;
            }
        }
    }

    void Window::CreateLogicalDevice() {
        if (!*m_PhysicalDevice) {
            throw std::runtime_error("Physical device not selected.");
        }

        auto queueFamilies = FindQueueFamilies(m_PhysicalDevice);

        float queuePriorities[1] = {1.0f};

        std::unordered_set<uint32_t> uniqueQueueFamilies = {
            queueFamilies.GraphicsFamily.value(),
            queueFamilies.PresentFamily.value()
        };

        std::vector<vk::DeviceQueueCreateInfo> queueCreateInfos;
        queueCreateInfos.reserve(uniqueQueueFamilies.size());
        for (const auto &queueFamily: uniqueQueueFamilies) {
            queueCreateInfos.push_back({
                .pNext = nullptr,
                .flags = {},
                .queueFamilyIndex = queueFamily,
                .queueCount = 1,
                .pQueuePriorities = queuePriorities
            });
        }

        vk::PhysicalDeviceFeatures deviceFeatures{};

        vk::DeviceCreateInfo deviceCreateInfo{
            .pNext = nullptr,
            .flags = {},
            .queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()),
            .pQueueCreateInfos = queueCreateInfos.data(),
            .enabledLayerCount = enableValidationLayers ? static_cast<uint32_t>(s_ValidationLayers.size()) : 0,
            .ppEnabledLayerNames = enableValidationLayers ? s_ValidationLayers.data() : nullptr,
            .enabledExtensionCount = static_cast<uint32_t>(s_DeviceExtensions.size()),
            .ppEnabledExtensionNames = s_DeviceExtensions.data(),
            .pEnabledFeatures = &deviceFeatures
        };

        m_Device = m_PhysicalDevice.createDevice(deviceCreateInfo).value();
        m_GraphicsQueue = m_Device.getQueue(queueFamilies.GraphicsFamily.value(), 0).value();
        m_PresentQueue = m_Device.getQueue(queueFamilies.PresentFamily.value(), 0).value();
    }

    void Window::CreateAllocator() {
        vma::AllocatorCreateInfo allocatorInfo{
            .flags = vma::AllocatorCreateFlagBits::eExtMemoryBudget,
            .physicalDevice = *m_PhysicalDevice,
            .device = *m_Device,
            .instance = *m_Instance,
            .vulkanApiVersion = vk::ApiVersion13
        };

        m_Allocator = vma::createAllocatorUnique(allocatorInfo).value;
    }

    void Window::CreateSurface() {
        auto sdlWindowProperties = SDL_GetWindowProperties(m_Window);
        // HWND hwnd = SDL_Vulkan_GetVkGetInstanceProcAddr();
        /*
        And, in case you missed it, you can get the HWND with the SDL_PROP_WINDOW_WIN32_HWND_POINTER property with the object returned by SDL_GetWindowProperties.
         */

        // extern SDL_DECLSPEC void * SDLCALL SDL_GetPointerProperty(SDL_PropertiesID props, const char *name, void *default_value);
        HWND hwnd = static_cast<HWND>(
            SDL_GetPointerProperty(sdlWindowProperties, SDL_PROP_WINDOW_WIN32_HWND_POINTER, nullptr));
        vk::Win32SurfaceCreateInfoKHR surfaceCreateInfo{
            .pNext = nullptr,
            .flags = {},
            .hinstance = GetModuleHandle(nullptr),
            .hwnd = hwnd
        };

        m_Surface = m_Instance.createWin32SurfaceKHR(surfaceCreateInfo).value();
    }

    QueueFamilyIndices Window::FindQueueFamilies(vk::PhysicalDevice physicalDevice) {
        QueueFamilyIndices indices;

        auto queueFamilies = physicalDevice.getQueueFamilyProperties();

        for (uint32_t i = 0; i < queueFamilies.size(); i++) {
            const auto &queueFamily = queueFamilies[i];

            if (queueFamily.queueFlags & vk::QueueFlagBits::eGraphics) {
                indices.GraphicsFamily = i;
            }

            if (physicalDevice.getSurfaceSupportKHR(i, *m_Surface).value) {
                indices.PresentFamily = i;
            }

            if (indices.IsComplete()) {
                break;
            }
        }

        return indices;
    }

    bool Window::IsDeviceSuitable(const vk::raii::PhysicalDevice &device) {
        auto queueFamilies = FindQueueFamilies(device);

        bool extensionSupported = CheckDeviceExtensionSupport(device);

        bool swapChainAdequate = false;

        if (extensionSupported) {
            auto swapChainSupport = QuerySwapChainSupport(device);
            swapChainAdequate = !swapChainSupport.Formats.empty() && !swapChainSupport.PresentModes.empty();
        }

        return queueFamilies.IsComplete() && extensionSupported && swapChainAdequate;
    }

    bool Window::CheckDeviceExtensionSupport(vk::PhysicalDevice device) const {
        auto availableExtensions = device.enumerateDeviceExtensionProperties().value;
        std::set<std::string> requiredExtensions(s_DeviceExtensions.begin(), s_DeviceExtensions.end());
        for (const auto &extension: availableExtensions) {
            requiredExtensions.erase(extension.extensionName);
        }
        if (requiredExtensions.empty()) {
            // std::cout << "All required device extensions are supported." << std::endl;
            return true;
        }
        std::cerr << "Not all required device extensions are supported!" << std::endl;
        for (const auto &ext: requiredExtensions) {
            std::cerr << "Missing extension: " << ext << std::endl;
        }
        return false;
    }

    SwapChainSupportDetails Window::QuerySwapChainSupport(vk::PhysicalDevice device) {
        SwapChainSupportDetails details;

        auto capabilities = device.getSurfaceCapabilitiesKHR(*m_Surface).value;
        auto formats = device.getSurfaceFormatsKHR(*m_Surface).value;
        auto presentModes = device.getSurfacePresentModesKHR(*m_Surface).value;

        return {
            .Capabilities = std::move(capabilities),
            .Formats = std::move(formats),
            .PresentModes = std::move(presentModes)
        };
    }

    vk::SurfaceFormatKHR Window::ChooseSwapSurfaceFormat(
        const std::vector<vk::SurfaceFormatKHR> &availableFormats) const {
        for (const auto &availableFormat: availableFormats) {
            if (availableFormat.format == vk::Format::eB8G8R8A8Unorm &&
                availableFormat.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {
                return availableFormat;
            }
        }

        return availableFormats.front();
    }

    vk::PresentModeKHR Window::ChooseSwapPresentMode(
        const std::vector<vk::PresentModeKHR> &availablePresentModes) const {
        return vk::PresentModeKHR::eFifo; // FIFO is guaranteed to be supported
    }

    vk::Extent2D Window::ChooseSwapExtent(const vk::SurfaceCapabilitiesKHR &capabilities) const {
        if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()

        ) {
            return capabilities.currentExtent;
        }

        int width, height;
        // Get frame buffer size from SDL
        SDL_GetWindowSize(m_Window, &width, &height);

        vk::Extent2D actualExtent = {
            .width = static_cast<uint32_t>(width),
            .height = static_cast<uint32_t>(height)
        };

        actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width,
                                        capabilities.maxImageExtent.width);
        actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height,
                                         capabilities.maxImageExtent.height);

        return actualExtent;
    }

    void Window::CreateSwapChain() {
        SwapChainSupportDetails swapChainSupport = QuerySwapChainSupport(*m_PhysicalDevice);

        auto surfaceFormat = ChooseSwapSurfaceFormat(swapChainSupport.Formats);
        auto presentMode = ChooseSwapPresentMode(swapChainSupport.PresentModes);
        auto extent = ChooseSwapExtent(swapChainSupport.Capabilities);

        uint32_t imageCount = swapChainSupport.Capabilities.minImageCount + 1;
        m_MinImageCount = swapChainSupport.Capabilities.minImageCount;
        m_ImageCount = imageCount;
        if (swapChainSupport.Capabilities.maxImageCount > 0 && imageCount > swapChainSupport.Capabilities.
            maxImageCount) {
            imageCount = swapChainSupport.Capabilities.maxImageCount;
        }

        auto queueFamilies = FindQueueFamilies(*m_PhysicalDevice);

        uint32_t queueFamilyIndices[] = {
            queueFamilies.GraphicsFamily.value(),
            queueFamilies.PresentFamily.value()
        };

        vk::SwapchainCreateInfoKHR swapChainCreateInfo{
            .pNext = nullptr,
            .flags = {},
            .surface = *m_Surface,
            .minImageCount = imageCount,
            .imageFormat = surfaceFormat.format,
            .imageColorSpace = surfaceFormat.colorSpace,
            .imageExtent = extent,
            .imageArrayLayers = 1,
            .imageUsage = vk::ImageUsageFlagBits::eColorAttachment,
            .imageSharingMode = queueFamilies.GraphicsFamily == queueFamilies.PresentFamily
                                    ? vk::SharingMode::eExclusive
                                    : vk::SharingMode::eConcurrent,
            .queueFamilyIndexCount = static_cast<uint32_t>((queueFamilies.GraphicsFamily == queueFamilies.PresentFamily)
                                                               ? 0
                                                               : 2),
            .pQueueFamilyIndices = (queueFamilies.GraphicsFamily == queueFamilies.PresentFamily)
                                       ? nullptr
                                       : queueFamilyIndices,
            .preTransform = swapChainSupport.Capabilities.currentTransform,
            .compositeAlpha = vk::CompositeAlphaFlagBitsKHR::eOpaque, // Opaque is a common choice
            .presentMode = presentMode,
            .clipped = vk::True,
            .oldSwapchain = m_SwapChain.release()
        };

        m_SwapChain = m_Device.createSwapchainKHR(swapChainCreateInfo).value();

        m_SwapChainImages = m_SwapChain.getImages();
        m_SwapChainImageFormat = surfaceFormat.format;
        m_SwapChainExtent = extent;
    }

    void Window::CreateImageViews() {
        m_SwapChainImageViews.reserve(m_SwapChainImages.size());

        for (const auto &image: m_SwapChainImages) {
            vk::ImageViewCreateInfo viewInfo{
                .pNext = nullptr,
                .flags = {},
                .image = image,
                .viewType = vk::ImageViewType::e2D,
                .format = m_SwapChainImageFormat,
                .components = {
                    .r = vk::ComponentSwizzle::eIdentity,
                    .g = vk::ComponentSwizzle::eIdentity,
                    .b = vk::ComponentSwizzle::eIdentity,
                    .a = vk::ComponentSwizzle::eIdentity
                },
                .subresourceRange = {
                    .aspectMask = vk::ImageAspectFlagBits::eColor,
                    .baseMipLevel = 0,
                    .levelCount = 1,
                    .baseArrayLayer = 0,
                    .layerCount = 1
                }
            };

            m_SwapChainImageViews.push_back(m_Device.createImageView(viewInfo).value());
        }
    }

    void Window::CreateDescriptorPool() {
        vk::DescriptorPoolSize poolSize{
            .type = vk::DescriptorType::eCombinedImageSampler,
            .descriptorCount = 10
        };

        vk::DescriptorPoolCreateInfo poolInfo{
            .flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet,
            .maxSets = 10,
            .poolSizeCount = 1,
            .pPoolSizes = &poolSize
        };

        m_DescriptorPool = m_Device.createDescriptorPool(poolInfo).value();
    }

    void Window::CreateSampler() {
        vk::SamplerCreateInfo samplerInfo{
            .magFilter = vk::Filter::eLinear,
            .minFilter = vk::Filter::eLinear,
            .mipmapMode = vk::SamplerMipmapMode::eLinear,
            .addressModeU = vk::SamplerAddressMode::eRepeat,
            .addressModeV = vk::SamplerAddressMode::eRepeat,
            .addressModeW = vk::SamplerAddressMode::eRepeat,
            .anisotropyEnable = vk::False,
            .borderColor = vk::BorderColor::eIntOpaqueBlack,
            .unnormalizedCoordinates = vk::False,
        };

        m_Sampler = m_Device.createSampler(samplerInfo).value();
    }

    inline void ImGuiUseStyleColorHazel() {
        auto &colors = ImGui::GetStyle().Colors;
        colors[ImGuiCol_WindowBg] = ImVec4{0.1f, 0.105f, 0.11f, 1.0f};

        // Headers
        colors[ImGuiCol_Header] = ImVec4{0.2f, 0.205f, 0.21f, 1.0f};
        colors[ImGuiCol_HeaderHovered] = ImVec4{0.3f, 0.305f, 0.31f, 1.0f};
        colors[ImGuiCol_HeaderActive] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};

        // Buttons
        colors[ImGuiCol_Button] = ImVec4{0.2f, 0.205f, 0.21f, 1.0f};
        colors[ImGuiCol_ButtonHovered] = ImVec4{0.3f, 0.305f, 0.31f, 1.0f};
        colors[ImGuiCol_ButtonActive] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};

        // Frame BG
        colors[ImGuiCol_FrameBg] = ImVec4{0.2f, 0.205f, 0.21f, 1.0f};
        colors[ImGuiCol_FrameBgHovered] = ImVec4{0.3f, 0.305f, 0.31f, 1.0f};
        colors[ImGuiCol_FrameBgActive] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};

        // Tabs
        // colors[ImGuiCol_Tab] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};
        // colors[ImGuiCol_TabHovered] = ImVec4{0.38f, 0.3805f, 0.381f, 1.0f};
        colors[ImGuiCol_Tab] = ImVec4(0.18f, 0.185f, 0.19f, 1.00f);
        colors[ImGuiCol_TabHovered] = ImVec4(0.28f, 0.285f, 0.29f, 1.00f);
        colors[ImGuiCol_TabSelected] = ImVec4(0.22f, 0.225f, 0.23f, 1.00f);
        colors[ImGuiCol_TabSelectedOverline] = ImVec4(0.35f, 0.40f, 0.60f, 1.00f);
        colors[ImGuiCol_TabDimmed] = ImVec4(0.13f, 0.135f, 0.14f, 1.00f);
        colors[ImGuiCol_TabDimmedSelected] = ImVec4(0.18f, 0.185f, 0.19f, 1.00f);
        colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.25f, 0.30f, 0.45f, 1.00f);

        // Title
        colors[ImGuiCol_TitleBg] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};
        colors[ImGuiCol_TitleBgActive] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};
        colors[ImGuiCol_TitleBgCollapsed] = ImVec4{0.15f, 0.1505f, 0.151f, 1.0f};

        // Resize Grip
        colors[ImGuiCol_ResizeGrip] = ImVec4(0.91f, 0.91f, 0.91f, 0.25f);
        colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.81f, 0.81f, 0.81f, 0.67f);
        colors[ImGuiCol_ResizeGripActive] = ImVec4(0.46f, 0.46f, 0.46f, 0.95f);

        // Scrollbar
        colors[ImGuiCol_ScrollbarBg] = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
        colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.31f, 0.31f, 0.31f, 1.0f);
        colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.41f, 0.41f, 0.41f, 1.0f);
        colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.0f);

        // Check Mark
        colors[ImGuiCol_CheckMark] = ImVec4(0.94f, 0.94f, 0.94f, 1.0f);

        // Slider
        colors[ImGuiCol_SliderGrab] = ImVec4(0.51f, 0.51f, 0.51f, 0.7f);
        colors[ImGuiCol_SliderGrabActive] = ImVec4(0.66f, 0.66f, 0.66f, 1.0f);

        // Docking
        // colors[ImGuiCol_DockingPreview] = ImVec4(0.31f, 0.31f, 0.31f, 0.7f);
        // colors[ImGuiCol_DockingEmptyBg] = ImVec4(0.02f, 0.02f, 0.02f, 1.0f);
    }

    void InitImGuiForMyProgram(uint32_t apiVersion,
                               vk::Instance instance, vk::PhysicalDevice physicalDevice,
                               vk::Device device, uint32_t queueFamily, vk::Queue queue, vk::DescriptorPool descriptorPool,
                               vk::RenderPass renderPass, uint32_t minImageCount, uint32_t imageCount) {

        ImGui_ImplVulkan_InitInfo info{};
        info.ApiVersion = apiVersion;
        info.Instance = instance;
        info.PhysicalDevice = physicalDevice;
        info.Device = device;
        info.QueueFamily = queueFamily;
        info.Queue = queue;
        info.DescriptorPool = descriptorPool;
        info.RenderPass = renderPass;
        info.MinImageCount = minImageCount;
        info.ImageCount = imageCount;

        ImGui_ImplVulkan_Init(&info);
    }

    void ShutdownImGuiForMyProgram() {
        ImGui_ImplVulkan_Shutdown();
    }

    void Window::InitImGui() {
        ImGui::CreateContext();

        ImGuiIO &io = ImGui::GetIO();
        (void) io;
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // Enable Gamepad Controls
        io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // Enable Docking
        io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; // Enable Multi-Viewport / Platform Windows
        //io.ConfigViewportsNoAutoMerge = true;
        //io.ConfigViewportsNoTaskBarIcon = true;

        // ImGui::StyleColorsDark();
        ImGuiUseStyleColorHazel();
        // ImGui::StyleColorsLight();

        // When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.
        ImGuiStyle &style = ImGui::GetStyle();
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) {
            style.WindowRounding = 0.0f;
            style.Colors[ImGuiCol_WindowBg].w = 1.0f;
        }

        ImGui_ImplSDL3_InitForVulkan(m_Window);

        InitImGuiForMyProgram(
            vk::ApiVersion13,
            *m_Instance,
            *m_PhysicalDevice,
            *m_Device,
            FindQueueFamilies(*m_PhysicalDevice).GraphicsFamily.value(),
            *m_GraphicsQueue,
            *m_DescriptorPool,
            *m_RenderPass,
            m_MinImageCount, m_ImageCount
        );
    }

    void Window::BeginImGuiFrame() {
        ImGui_ImplVulkan_NewFrame();
        ImGui_ImplSDL3_NewFrame();
        ImGui::NewFrame();
    }

    void Window::CreateRenderPass() {
        // disable v-sync
        vk::AttachmentDescription colorAttachment{
            .flags = {},
            .format = m_SwapChainImageFormat,
            .samples = vk::SampleCountFlagBits::e1,
            .loadOp = vk::AttachmentLoadOp::eClear,
            .storeOp = vk::AttachmentStoreOp::eStore,
            .stencilLoadOp = vk::AttachmentLoadOp::eDontCare,
            .stencilStoreOp = vk::AttachmentStoreOp::eDontCare,
            .initialLayout = vk::ImageLayout::eUndefined,
            .finalLayout = vk::ImageLayout::ePresentSrcKHR
        };

        vk::AttachmentReference colorAttachmentRef{
            .attachment = 0, // Index of the attachment in the render pass
            .layout = vk::ImageLayout::eColorAttachmentOptimal
        };

        vk::SubpassDescription subpass{
            .flags = {},
            .pipelineBindPoint = vk::PipelineBindPoint::eGraphics,
            .inputAttachmentCount = 0,
            .pInputAttachments = nullptr,
            .colorAttachmentCount = 1,
            .pColorAttachments = &colorAttachmentRef,
            .pResolveAttachments = nullptr,
            .pDepthStencilAttachment = nullptr,
            .preserveAttachmentCount = 0,
            .pPreserveAttachments = nullptr
        };

        vk::SubpassDependency dependency{
            .srcSubpass = vk::SubpassExternal, // No previous subpass
            .dstSubpass = 0, // Our subpass
            .srcStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput,
            .dstStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput,
            .srcAccessMask = {},
            .dstAccessMask = vk::AccessFlagBits::eColorAttachmentWrite,
            .dependencyFlags = {}
        };

        vk::RenderPassCreateInfo renderPassInfo{
            .pNext = nullptr,
            .flags = {},
            .attachmentCount = 1,
            .pAttachments = &colorAttachment,
            .subpassCount = 1,
            .pSubpasses = &subpass,
            .dependencyCount = 1,
            .pDependencies = &dependency
        };

        m_RenderPass = m_Device.createRenderPass(renderPassInfo).value();
    }

    void Window::CreateFramebuffers() {
        m_SwapChainFramebuffers.reserve(m_SwapChainImageViews.size());

        for (const auto &imageView: m_SwapChainImageViews) {
            vk::ImageView attachments[] = {
                *imageView // Single attachment for color
            };

            vk::FramebufferCreateInfo framebufferInfo{
                .pNext = nullptr,
                .flags = {},
                .renderPass = *m_RenderPass,
                .attachmentCount = 1,
                .pAttachments = attachments,
                .width = m_SwapChainExtent.width,
                .height = m_SwapChainExtent.height,
                .layers = 1 // Single layer for 2D images
            };

            m_SwapChainFramebuffers.push_back(
                m_Device.createFramebuffer(framebufferInfo).value()
            );
        }
    }

    void Window::CreateCommandPool() {
        auto queueFamilies = FindQueueFamilies(*m_PhysicalDevice);
        if (!queueFamilies.GraphicsFamily.has_value()) {
            throw std::runtime_error("Graphics queue family not found.");
        }
        vk::CommandPoolCreateInfo poolInfo{
            .pNext = nullptr,
            .flags = vk::CommandPoolCreateFlagBits::eResetCommandBuffer,
            .queueFamilyIndex = queueFamilies.GraphicsFamily.value()
        };

        m_CommandPool = m_Device.createCommandPool(poolInfo).value();
    }

    // void Window::CreateCommandBuffer() {
    //     vk::CommandBufferAllocateInfo allocInfo{
    //         .pNext = nullptr,
    //         .commandPool = *m_CommandPool,
    //         .level = vk::CommandBufferLevel::ePrimary,
    //         .commandBufferCount = 1
    //     };
    //
    //     for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    //         m_CommandBuffers.push_back(std::move(m_Device.allocateCommandBuffers(allocInfo).value().front()));
    //     }
    //
    //     // m_CommandBufferDependentContexts.resize(MAX_FRAMES_IN_FLIGHT);
    // }

    // void Window::CreateSyncObjects() {
    //     vk::SemaphoreCreateInfo semaphoreInfo{
    //         .pNext = nullptr,
    //         .flags = {}
    //     };
    //     vk::FenceCreateInfo fenceInfo{
    //         .pNext = nullptr,
    //         .flags = vk::FenceCreateFlagBits::eSignaled // Start with the fence signaled
    //     };
    //
    //     for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    //         m_ImageAvailableSemaphores.push_back(m_Device.createSemaphore(semaphoreInfo).value());
    //         m_InFlightFences.push_back(m_Device.createFence(fenceInfo).value());
    //     }
    //
    //     // m_InFlightFence = m_Device.createFence(fenceInfo).value();
    //     for (size_t i = 0; i < m_SwapChainImages.size(); i++) {
    //         m_RenderFinishedSemaphores.push_back(m_Device.createSemaphore(semaphoreInfo).value());
    //     }
    // }



    void Window::RecreateSwapChain() {
        m_Device.waitIdle();

        CleanupSwapChain();

        CreateSwapChain();
        CreateImageViews();
        CreateFramebuffers();

        std::cout << "Swap chain recreated successfully." << std::endl;
    }

    void Window::CleanupSwapChain() {
        m_SwapChainFramebuffers.clear();
        m_SwapChainImageViews.clear();
        m_SwapChainImages.clear();

        m_SwapChain.clear();
    }

    void Window::DispatchNormalEvent(SDL_Event sdlEvent) {
        switch (sdlEvent.type) {
            case SDL_EVENT_KEY_DOWN: {
                KeyPressedEvent event{
                    Key::KeyCode(sdlEvent.key.key),
                    sdlEvent.key.repeat
                };
                for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                    if ((*reverseIt)->OnEvent(event)) {
                        break;
                    }
                }
                break;
            }
            case SDL_EVENT_KEY_UP: {
                KeyReleasedEvent event{
                    Key::KeyCode(sdlEvent.key.key)
                };
                for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                    if ((*reverseIt)->OnEvent(event)) {
                        break;
                    }
                }
                break;
            }
            case SDL_EVENT_MOUSE_BUTTON_DOWN: {
                MouseButtonPressedEvent event{
                    Mouse::MouseCode(sdlEvent.button.button)
                };
                for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                    if ((*reverseIt)->OnEvent(event)) {
                        break;
                    }
                }
                break;
            }
            case SDL_EVENT_MOUSE_BUTTON_UP: {
                MouseButtonReleasedEvent event{
                    Mouse::MouseCode(sdlEvent.button.button)
                };
                for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                    if ((*reverseIt)->OnEvent(event)) {
                        break;
                    }
                }
                break;
            }
            case SDL_EVENT_MOUSE_MOTION: {
                MouseMovedEvent event{
                    sdlEvent.motion.x,
                    sdlEvent.motion.y
                };
                for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                    if ((*reverseIt)->OnEvent(event)) {
                        break;
                    }
                }
                break;
            }
        }
    }

    void Window::MainLoop() {
        SDL_SetWindowPosition(m_Window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);
        SDL_ShowWindow(m_Window);
        bool done = false;

        while (!done) {
            // Poll and handle events (inputs, window resize, etc.)
            // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
            // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.
            // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.
            // Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
            // [If using SDL_MAIN_USE_CALLBACKS: call ImGui_ImplSDL3_ProcessEvent() from your SDL_AppEvent() function]
            SDL_Event event;
            while (SDL_PollEvent(&event)) {
                ImGui_ImplSDL3_ProcessEvent(&event);
                if (event.type == SDL_EVENT_QUIT) {
                    done = true;
                    WindowCloseEvent event{};
                    for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                        if ((*reverseIt)->OnEvent(event)) {
                            break;
                        }
                    }
                } else if (event.type == SDL_EVENT_WINDOW_CLOSE_REQUESTED && event.window.windowID ==
                           SDL_GetWindowID(m_Window)) {
                    done = true;
                    WindowCloseEvent event{};
                    for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                        if ((*reverseIt)->OnEvent(event)) {
                            break;
                        }
                    }
                } else if (event.type == SDL_EVENT_WINDOW_RESIZED || event.type == SDL_EVENT_WINDOW_MINIMIZED ||
                           event.type == SDL_EVENT_WINDOW_MAXIMIZED) {
                    int width, height;
                    width = event.window.data1;
                    height = event.window.data2;

                    if (width > 0 && height > 0) {
                        m_ShouldUpdate = true;
                        if (width != m_SwapChainExtent.width || height != m_SwapChainExtent.height) {
                            RecreateSwapChain();
                        }
                    } else {
                        m_ShouldUpdate = false;
                    }

                    WindowResizeEvent event{static_cast<uint32_t>(width), static_cast<uint32_t>(height)};
                    for (auto reverseIt = m_Layers.rbegin(); reverseIt != m_Layers.rend(); ++reverseIt) {
                        if ((*reverseIt)->OnEvent(event)) {
                            break;
                        }
                    }
                } else if (event.type == SDL_EVENT_WINDOW_RESTORED) {
                    m_ShouldUpdate = true;
                } else DispatchNormalEvent(event);
            }

            if (!m_ShouldUpdate) {
                continue;
                std::this_thread::sleep_for(std::chrono::milliseconds(16));
            }
            DrawFrame();
        }

        m_Device.waitIdle();
        m_Layers.clear();
    }


    void Window::Cleanup() {
        CleanupSwapChain();

        ShutdownImGuiForMyProgram();
        ImGui_ImplSDL3_Shutdown();
        ImGui::DestroyContext();
    }

    void Window::OnUpdate() {
        for (auto &layer: m_Layers) {
            layer->OnUpdate();
        }
    }

    bool QueueFamilyIndices::IsComplete() const {
        return GraphicsFamily.has_value() && PresentFamily.has_value();
    }
}
